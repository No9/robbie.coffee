// Generated by CoffeeScript 1.3.3
var CUP, EMPTY, Simulation, WALL, allways_random, max_fitness, random_strategy, run, weighted_choice;

EMPTY = 0;

CUP = 1;

WALL = 2;

Simulation = (function() {

  function Simulation(strategy) {
    this.strategy = strategy;
    this.board = this.random_board();
    this.score = 0;
    this.x = 1;
    this.y = 1;
  }

  Simulation.prototype.reset = function() {
    this.board = this.random_board();
    this.score = 0;
    this.x = 1;
    return this.y = 1;
  };

  Simulation.prototype.random_board = function() {
    var x, y, _i, _results;
    _results = [];
    for (y = _i = 0; _i <= 11; y = ++_i) {
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (x = _j = 0; _j <= 11; x = ++_j) {
          if (x === 0 || y === 0 || x === 11 || y === 11) {
            _results1.push(WALL);
          } else if (Math.random() < 0.5) {
            _results1.push(CUP);
          } else {
            _results1.push(EMPTY);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  Simulation.prototype.step = function() {
    var current, down, left, move, right, strategy_index, up;
    up = this.board[this.y - 1][this.x];
    down = this.board[this.y + 1][this.x];
    left = this.board[this.y][this.x - 1];
    right = this.board[this.y][this.x + 1];
    current = this.board[this.y][this.x];
    strategy_index = this.strategy_index(up, down, left, right, current);
    move = this.strategy[strategy_index];
    return this.move(move);
  };

  Simulation.prototype.run = function(display_fn) {
    var i, _i;
    this.reset();
    for (i = _i = 0; _i < 200; i = ++_i) {
      this.step();
    }
    return this.score;
  };

  Simulation.prototype.move = function(move) {
    var current, down, left, right, up;
    up = this.board[this.y - 1][this.x];
    down = this.board[this.y + 1][this.x];
    left = this.board[this.y][this.x - 1];
    right = this.board[this.y][this.x + 1];
    current = this.board[this.y][this.x];
    switch (move) {
      case 'N':
        if (up === WALL) {
          return this.score -= 5;
        } else {
          return this.y -= 1;
        }
        break;
      case 'E':
        if (right === WALL) {
          return this.score -= 5;
        } else {
          return this.x += 1;
        }
        break;
      case 'S':
        if (down === WALL) {
          return this.score -= 5;
        } else {
          return this.y += 1;
        }
        break;
      case 'W':
        if (left === WALL) {
          return this.score -= 5;
        } else {
          return this.x -= 1;
        }
        break;
      case '0':
        return '';
      case 'G':
        if (this.board[this.y][this.x] === CUP) {
          this.board[this.y][this.x] = EMPTY;
          return this.score += 10;
        } else {
          return this.score -= 1;
        }
        break;
      case 'R':
        return this.move(_.random(['N', 'E', 'S', 'W']));
    }
  };

  Simulation.prototype.display_console = function() {
    var board, x, y, _i;
    console.log('***********************');
    console.log(this.score);
    board = (function() {
      var _i, _results;
      _results = [];
      for (x = _i = 0; _i <= 11; x = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; _j <= 11; y = ++_j) {
            if (x === this.x && y === this.y) {
              _results1.push('R');
            } else {
              _results1.push(this.board[y][x]);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    }).call(this);
    for (y = _i = 0; _i <= 11; y = ++_i) {
      console.log(board[y].join());
    }
    return '';
  };

  Simulation.prototype.display_canvas = function(element_id) {
    var background, board, cell_size, context, coords, fill_colour, line_colour, x, y, _i, _j;
    board = document.getElementById(element_id);
    context = board.getContext('2d');
    line_colour = '#cdcdcd';
    background = '#fff';
    fill_colour = '#666';
    context.fillStyle = background;
    context.fillRect(0, 0, board.width, board.height);
    cell_size = board.width / 12;
    context.strokeStyle = line_colour;
    context.fillStyle = fill_colour;
    for (x = _i = 1; _i <= 10; x = ++_i) {
      for (y = _j = 1; _j <= 10; y = ++_j) {
        coords = [x * cell_size, y * cell_size, cell_size, cell_size];
        context.strokeRect.apply(context, coords);
        if (this.board[y][x] === CUP) {
          context.beginPath();
          context.arc(x * cell_size + cell_size / 2, y * cell_size + cell_size / 2, 5, 0, Math.PI * 2, true);
          context.closePath();
          context.fill();
        }
      }
    }
    context.beginPath();
    context.arc(this.x * cell_size + cell_size / 2, this.y * cell_size + cell_size / 2, 20, 0, Math.PI * 2, true);
    context.closePath();
    context.fill();
    return null;
  };

  Simulation.prototype.strategy_index = function(up, down, left, right, current) {
    return up * Math.pow(3, 4) + down * Math.pow(3, 3) + left * Math.pow(3, 2) + right * Math.pow(3, 1) + current;
  };

  Simulation.prototype.fitness = function() {
    var i, tot;
    tot = 0;
    i = 0;
    while (i < 100) {
      this.reset();
      tot += this.run();
      i++;
    }
    return tot / 100;
  };

  return Simulation;

})();

random_strategy = function() {
  var i, strategy, _i;
  strategy = '';
  for (i = _i = 0; _i < 242; i = ++_i) {
    strategy += _.random(['N', 'E', 'S', 'W', 'G', '0', 'R']);
  }
  return strategy;
};

allways_random = function() {
  var i, strategy, _i;
  strategy = '';
  for (i = _i = 0; _i < 242; i = ++_i) {
    strategy += 'R';
  }
  console.log(strategy);
  return strategy;
};

max_fitness = function(population) {
  var max, strategy, _i, _len;
  max = population[0];
  for (_i = 0, _len = population.length; _i < _len; _i++) {
    strategy = population[_i];
    if (strategy.fitness > max.fitness) {
      max = strategy;
    }
  }
  return max;
};

weighted_choice = function(population) {
  var i, l, position, so_far, total;
  l = population.length;
  total = (l + 1) / 2 * l;
  position = Math.ceil(Math.random() * total);
  i = 0;
  so_far = l;
  while (so_far < position) {
    l = l - 1;
    so_far += l;
    i++;
  }
  return _.sortBy(population, function(strategy) {
    return strategy.fitness;
  })[population.length - 1 - i];
};

run = function() {
  var dna, evolve, i, population, _i;
  population = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; _i < 200; i = ++_i) {
      dna = random_strategy();
      _results.push({
        dna: dna,
        fitness: (new Simulation(dna)).fitness()
      });
    }
    return _results;
  })();
  evolve = function() {
    var dna1, dna2, new_population, s1, s2, splitpoint, _i, _j, _k, _ref, _ref1;
    new_population = [];
    for (i = _i = 0; _i < 100; i = ++_i) {
      s1 = weighted_choice(population).dna;
      s2 = weighted_choice(population).dna;
      splitpoint = Math.floor(Math.random() * s1.length);
      dna1 = s1.slice(0, splitpoint) + s2.slice(splitpoint, s2.length);
      for (i = _j = 0, _ref = dna1.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        if (Math.random() < 0.001) {
          dna1 = dna1.slice(0, i) + _.random(['N', 'E', 'S', 'W', 'G', '0', 'R']) + dna1.slice(i + 1, dna1.length);
        }
      }
      dna2 = s2.slice(0, splitpoint) + s1.slice(splitpoint, s1.length);
      for (i = _k = 0, _ref1 = dna2.length; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
        if (Math.random() < 0.001) {
          dna2 = dna2.slice(0, i) + _.random(['N', 'E', 'S', 'W', 'G', '0', 'R']) + dna2.slice(i + 1, dna2.length);
        }
      }
      new_population.push({
        dna: dna1,
        fitness: (new Simulation(dna1)).fitness()
      });
      new_population.push({
        dna: dna2,
        fitness: (new Simulation(dna2)).fitness()
      });
    }
    population = new_population;
    return console.log(max_fitness(population));
  };
  for (i = _i = 0; _i < 20; i = ++_i) {
    console.log("Generation " + i);
    evolve();
  }
  return 0;
};

window.robbie = function() {
  var animation_rate, count, s, step, test;
  test = 'NG0EGRWGWWGNWWEWG0SGREGS00NSGWSSRWGWSWNWWSREESGESGEEEREGGEGNNGGEGEEG0NEGEGGEGW0EGNGSEGGWGSWGEWWWNGSRNENG0GSRNSWSS0SGSSW0WWRGNWEGNRGSSS0NGEEGRNGRWGSWGWRNW0RG00WGWNWGREGRWGEWGSEGGNN0SGESGWGERSG0ES0SGSWSSRSWS0RSG0SGER0SGRNGEEESRRGERESG0SNEEWSN0G';
  s = new Simulation(test);
  s.display_canvas('board');
  animation_rate = 100;
  count = 0;
  step = function() {
    s.step();
    s.display_canvas('board');
    count++;
    if (count === 200) {
      s.reset();
      count = 0;
    }
    return setTimeout(step, animation_rate);
  };
  return step();
};

window.Simulation = Simulation;

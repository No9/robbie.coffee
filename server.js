// Generated by CoffeeScript 1.3.3
(function() {
  var Simulation, app, dna, evolve, express, http, i, io, max_fitness, path, random_strategy, routes, server, update_population, weighted_choice;

  express = require('express');

  http = require('http');

  routes = require('./routes');

  path = require('path');

  require('./public/javascripts/tth_');

  Simulation = require('./public/javascripts/robbie/simulation.js').Simulation;

  app = express();

  app.configure(function() {
    app.set('port', process.env.PORT || 9292);
    app.set('views', __dirname + '/views');
    app.set('view engine', 'jade');
    app.use(express.favicon());
    app.use(express.logger('dev'));
    app.use(express.bodyParser());
    app.use(express.methodOverride());
    app.use(app.router);
    return app.use(express["static"](path.join(__dirname, 'public')));
  });

  app.configure('development', function() {
    return app.use(express.errorHandler());
  });

  server = http.createServer(app).listen(app.get('port'), function() {
    return console.log("Express serverlistening on port " + app.get('port'));
  });

  random_strategy = function() {
    var i, strategy, _i;
    strategy = '';
    for (i = _i = 0; _i < 242; i = ++_i) {
      strategy += _.random(['N', 'E', 'S', 'W', 'G', '0', 'R']);
    }
    return strategy;
  };

  max_fitness = function(population) {
    var max, strategy, _i, _len;
    max = population[0];
    for (_i = 0, _len = population.length; _i < _len; _i++) {
      strategy = population[_i];
      if (strategy.fitness > max.fitness) {
        max = strategy;
      }
    }
    return max;
  };

  global.population = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; _i < 100; i = ++_i) {
      dna = random_strategy();
      _results.push({
        dna: dna,
        fitness: (new Simulation(dna)).fitness()
      });
    }
    return _results;
  })();

  io = require('socket.io').listen(server);

  io.set("log level", 1);

  io.sockets.on('connection', function(client) {
    return client.on('result', function(new_population) {
      console.log("got result");
      global.population.concat(new_population);
      return null;
    });
  });

  app.get('/robbie', function(req, res) {
    return res.render('robbie/index', {
      title: "Evolving Robbie"
    });
  });

  app.get('/robbie/hoipe', function(req, res) {
    return res.render('robbie/hoipe', {
      title: "Here's one I prepared earlier"
    });
  });

  weighted_choice = function(population) {
    var l, position, so_far, total;
    l = population.length;
    total = (l + 1) / 2 * l;
    position = Math.ceil(Math.random() * total);
    i = 0;
    so_far = l;
    while (so_far < position) {
      l = l - 1;
      so_far += l;
      i++;
    }
    return _.sortBy(population, function(strategy) {
      return strategy.fitness;
    })[population.length - 1 - i];
  };

  evolve = function(population) {
    var dna1, dna2, new_population, s1, s2, splitpoint, _i, _j, _k, _ref, _ref1, _ref2;
    new_population = [];
    for (i = _i = 0, _ref = population.length / 2; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      s1 = weighted_choice(population).dna;
      s2 = weighted_choice(population).dna;
      splitpoint = Math.floor(Math.random() * s1.length);
      dna1 = s1.slice(0, splitpoint) + s2.slice(splitpoint, s2.length);
      for (i = _j = 0, _ref1 = dna1.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        if (Math.random() < 0.001) {
          dna1 = dna1.slice(0, i) + _.random(['N', 'E', 'S', 'W', 'G', '0', 'R']) + dna1.slice(i + 1, dna1.length);
        }
      }
      dna2 = s2.slice(0, splitpoint) + s1.slice(splitpoint, s1.length);
      for (i = _k = 0, _ref2 = dna2.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        if (Math.random() < 0.001) {
          dna2 = dna2.slice(0, i) + _.random(['N', 'E', 'S', 'W', 'G', '0', 'R']) + dna2.slice(i + 1, dna2.length);
        }
      }
      new_population.push({
        dna: dna1,
        fitness: -1000
      });
      new_population.push({
        dna: dna2,
        fitness: -1000
      });
    }
    console.log("Max fitness is " + (max_fitness(population).fitness));
    return new_population;
  };

  update_population = function() {
    global.population = evolve(population);
    return io.sockets.emit('population', global.population);
  };

  update_population();

  setInterval(update_population, 1000);

}).call(this);
